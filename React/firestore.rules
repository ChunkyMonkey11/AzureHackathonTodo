/**
 * Firestore Security Rules
 * Defines access control and validation rules for the Firestore database
 * Implements a permission-based system for todo sharing and management
 */

rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    /**
     * Helper Functions
     * These functions are used throughout the rules to check permissions
     */

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if user owns the todo
    function isOwner(todoData) {
      return request.auth.token.email == todoData.owner;
    }

    // Helper function to check if user is the original owner
    function isOriginalOwner(todoData) {
      return request.auth.token.email == todoData.originalOwner;
    }

    // Helper function to check if user has edit permission
    function hasEditPermission(todoData) {
      return isOwner(todoData) || isOriginalOwner(todoData) || (
        todoData.permission == 'edit'
      );
    }

    // Helper function to check if user has view permission
    function hasViewPermission(todoData) {
      return isOwner(todoData) || isOriginalOwner(todoData) || (
        todoData.permission == 'view' || todoData.permission == 'edit'
      );
    }

    // Helper function to validate new todo data
    function isValidNewTodo() {
      let todo = request.resource.data;
      return todo.text is string &&
             todo.text.size() > 0 &&
             todo.text.size() <= 500 &&
             todo.description is string &&
             todo.completed is bool &&
             todo.category in ['personal', 'work', 'shopping', 'other'] &&
             todo.priority in ['high', 'medium', 'low'] &&
             todo.createdAt is timestamp &&
             todo.userId is string &&
             todo.owner is string &&
             todo.originalOwner is string;
    }

    // Helper function to validate todo updates
    function isValidTodoUpdate() {
      let todo = request.resource.data;
      return todo.text is string &&
             todo.text.size() > 0 &&
             todo.text.size() <= 500 &&
             todo.description is string &&
             todo.completed is bool &&
             todo.category in ['personal', 'work', 'shopping', 'other'] &&
             todo.priority in ['high', 'medium', 'low'];
    }

    /**
     * Collection Rules
     * Define access control for each collection in the database
     */

    // Rules for the todos collection
    match /todos/{todoId} {
      allow create: if isAuthenticated() && isValidNewTodo() && 
                   request.resource.data.userId == request.auth.uid &&
                   request.resource.data.owner == request.auth.token.email &&
                   request.resource.data.originalOwner == request.auth.token.email;
      
      allow read: if isAuthenticated();
      
      allow update: if isAuthenticated() && hasEditPermission(resource.data) && isValidTodoUpdate();
      
      allow delete: if isAuthenticated() && isOwner(resource.data);
    }

    // Rules for the users collection
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == userId;
      allow update: if isAuthenticated() && request.auth.uid == userId;
      allow delete: if isAuthenticated() && request.auth.uid == userId;
      
      // Rules for shared_todos subcollection
      match /shared_todos/{sharedTodoId} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }

      // Rules for invited_todos subcollection
      match /invited_todos/{invitationId} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }

      // Rules for recently_deleted subcollection
      match /recently_deleted/{todoId} {
        allow read, write: if isAuthenticated() && request.auth.uid == userId;
      }
    }

    // Rules for the userProfiles collection
    match /userProfiles/{email} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated() && request.auth.token.email == email;
    }
  }
} 